---
layout: post 
author: 零度
title: 阿里JAVA开发手册零度的思考理解(一)
category: thought
tags: [thought]
excerpt: 阿里JAVA开发手册零度的思考理解(一)。
---





## 缘由
**阿里JAVA开发手册已经发表有很长时间了，值得认真研究思考推广**
>- 阿里官方的Java代码规范标准，这份开发手册不仅规范了一些开发细节，也提出了很多工程开发的哲学，值得好好阅读。
>
>
>- 可谓包罗万象，几乎日常Java开发中方方面面都有所涉及。
>
>
>- 每一条都是前人踩过的坑，通过血的教训总结出来的。
>
>
>- 能公布出来真是造福全部Java开发者。
>
>
>- 开发手册详细列举如何开发更加高效，更加容错，更加有协作性，力求知其然，更知其不然，结合正反例，提高代码质量。比如，异常日志处理时的各种不规范行为；集合转换的各种坑；创建线程池出现的等待队列OOM等。 

的确阿里JAVA开发手册值得我们好好阅读和思考，每一条都是前人踩过的坑，通过血的教训总结出来的。所以今天就其中一点自己的思考理解进行分享。



![阿里JAVA开发手册](http://upload-images.jianshu.io/upload_images/7849276-0971bc93d5e12632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


看完这条，个人觉得主要是**圈复杂度**，由于代码是人写的，并且需要人来进行维护，如果足够的复杂的话，那么编写出现错误的可能性都很大，并且维护理解起来难度也非常高，以及后期如果需要扩展本来就很复杂再加一个很简单的功能都变得很困难（相信大家一定都有这样的经历）。

## 圈复杂度
>圈复杂度(Cyclomatic complexity)是一种代码复杂度的衡量标准。
>在软件测试的概念里，圈复杂度用来衡量一个模块判定结构的复杂程度，数量上表现为独立线性路径条数，即合理的预防错误所需测试的最少路径条数。**圈复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。**

看看上面阿里JAVA开发手册里面提到的，**如果非得使用if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请匆超过3层。如果超过3层的if-else的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现。**

其实在我看来，使用卫语句、策略模式、状态模式就是来降低圈复杂度，让代码更加简单，这样不管是编写代码人员以及维护人员都可以非常方便了解到本质意思。

**虽然阿里JAVA开发手册提到的是if()...else if()...else...方式表达逻辑，延伸下，关于多次嵌套循环等道理也一样，需要考虑优化的。**

## 思路分析
![判断树](http://upload-images.jianshu.io/upload_images/7849276-bfc63473c5a4326f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如上图，其实看起来就是**一颗树结构**，相对来说其实比较复杂了，优化的思路其实就是把树结构变成顺序结构即可，那样条理就清晰了，总体思路是这样的，下面看看使用卫语句、策略模式、状态模式怎么达到的。

## 卫语句
**卫语句？**卫语句就是把复杂的条件表达式拆分成多个条件表达式，比如一个很复杂的表达式，嵌套了好几层的if - then-else语句，转换为多个if语句，实现它的逻辑，这多条的if语句就是卫语句。

**其中卫语句示例如下：**
``` java
public void today() {
    if (isBusy()) {
        System.out.println("change time.");
        return;
    }
    if (isFree()) {
        System.out.println("go to travel."); 
        return;
    }
    System.out.println("stay at home to learn Alibaba Java Coding Guidelines.");
    return;
}
```
其实这个比较简单，每一个if对应叶子节点的一条路径（每个if基本就return了）。


## 策略模式
**概述：**使用这个模式来将一组算法封装成一系列对象。通过传递这些对象可以灵活的改变程序的功能。

策略模式比较有名的就是**诸葛亮的三个锦囊妙计**说起，如图：
![](http://upload-images.jianshu.io/upload_images/7849276-0e6d30761b484121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**诸葛亮为什么要这么麻烦，做三个锦囊？**他完全可以只做一个锦囊，将这三个妙计都写在它上面。可他没有这么做，而是正确的运用了策略模式做了三个锦囊。**这样做的好处十分明显**：**诸葛亮一个锦囊写一个妙计，他的思路十分清晰，不会三个计策相互混乱。**而**赵云看妙计的时候也十分方便，什么时候看哪个妙计，使用十分方便**，如果三个妙计混在一起，他就没这么方便了。

在JDK中java.util.Comparator#compare()就是使用的策略模式，比如我们经常对商品进行排序，条件有很多啊，按照商品浏览量、价格、更新时间、【价格、时间】、【浏览量、更新时间】（进行升序、降序操作）其实这个也是上面那颗树，需要做的就是每次取其中一条叶子节点。很多时候这些判断都是写在一个公用的方法里面，进行大量的判断之后写排序，而JDK怎么做的呢？把变化的比较判断拿出来，**其实判断树中每个叶子结点就是一种策略**，想象我们平时怎么做的呢？ 都是把Comparator#compare()写好（可能有很多实现Comparator接口的排序算法）每次我们调用的时候选择其中一种即可。

**与卫语句不同的是，卫语句把每一个if对应叶子节点的一条路径。而策略模式是所以叶子都在实现Comparator接口了，具体开始用那个是调用的直接用（所以不会像卫语句那样看见很多if了）**

## 状态模式
**概述**：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。主要解决的是对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。

1. 封装了转换规则。 
2. 枚举可能的状态，在枚举状态之前需要确定状态种类。 
3. 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 
4. 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 
5. 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 

由于状态模式是封装了转换规则，所以一般树的深度最少需要2层以及上，个人理解的感觉就是一个流程了，比如***水低于0度是冰的状态--> 大于0度又变成液态--> 100度又变成沸腾的状态**

状态模式与策略模式很像，策略模式是外驱动，而状态模式是内驱动。本质也是把判断树里面只取其中一条叶子的路径。

状态模式有一个**明显的缺点**：状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 

## 程序员笑话
老婆给当程序员的老公打电话：下班顺路买十个包子，如果看到卖西瓜的，买一个。当晚老公手捧一个包子进了家门…老婆怒道：你怎么只买一个包子？！老公甚恐，喃喃道：因为我真看到卖西瓜的了。”

如果使用策略模式就简单了，2条信息，1：买十个包子。2：买一个西瓜，没有就算了。
**虽然是个笑话，但是顺序的就是比判断的要简单。**

## 总结
-  圈复杂度概念
- 卫语句
- 策略模式
- 状态模式

**汇总：本质就是把较深的判断树，使用的时候，就是把判断树结构变成顺序结构即可，就是给出每个叶子的路径而不需要看起来是一颗复杂的树结构。**




## 思考
![阿里JAVA开发手册](http://upload-images.jianshu.io/upload_images/7849276-6e6ffb470ba18275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这是阿里JAVA开发手册其中一条明细，**为什么呢，结果是啥，怎么出乎意料啦？？期待你的留言和分析！！！**


--------------
上面的一些分析都是个人自己的理解和思考，如果发现有不对的希望留言指出，谢谢！！！
**如果读完觉得有收获的话，欢迎点赞加关注。**
